#/bin/python3
# -*- coding: utf-8 -*-
"""day10_exercicios_dictionaries.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oe09snSvblCkajrOcLKLebTWADisG6tg
"""

# 1) Below is a tuple describing an album:
album = (
    "The Dark Side of the Moon",
    "Pink Floyd",
    1973,
    (
        "Speak to Me",
        "Breathe",
        "On the Run",
        "Time",
        "The Great Gig in the Sky",
        "Money",
        "Us and Them",
        "Any Colour You Like",
        "Brain Damage",
        "Eclipse"
    )
 )
# Inside the tuple we have the album name, the artist (in this case, the band), the year of release, and then another tuple containing the track list.

# Convert this outer tuple to a dictionary with four keys

album_dict = {"album_name": album[0],
              "artist": album[1],
              "year_of_release": album[2],
              "songs": album[3]}
print(album_dict.items())

# 2) Iterate over the keys and values of the dictionary you create in exercise 1.
# For each key and value, you should print the name of the key, and then the value alongside it.
for key, value in album_dict.items():
  print(f'{key} = {value}')

# 3) Delete the track list and year of release from the dictionary you created. Once you've done this, add a new key to the dictionary to store the date of release.
# The date of release for The Dark Side of the Moon was March 1st, 1973.
del album_dict['songs']
del album_dict['year_of_release']
album_dict['date_of_release'] = 'March 1st, 1973'
print(album_dict.items())

# 4) Try to retrieve one of the values you deleted from the dictionary. This should give you a KeyError.
# Once you've tried this, repeat the step using the get method to prevent the exception being raised.

# The line below is comented to avoid a exception being raised
# album_dict['songs']
album_dict.get('songs', 'Key not found')

"""# Sets



"""

# When we declare a empty dictionary we use assign {}, so because of that to declare a empty set we assign set()
uwu_set = set()
print(uwu_set)

# Adding items to a set
vegetables = {"carrot", "lettuce", "broccoli", "onion"}
vegetables.add("potato")

print(vegetables)  # {'lettuce', 'broccoli', 'onion', 'potato', 'carrot'}
# this will be in a different order
# adding more than 1 item
vegetables.update({"pumpkin", "parsley"})
print(vegetables)

# removing items
vegetables.remove("pumpkin")
print(vegetables)
last_item_removed = vegetables.pop()
print(last_item_removed)
vegetables.discard("parsley")
print(vegetables)

# Union: creates a new set
letters = {"a", "b", "c"}
numbers = {1, 2, 3}

letters_and_numbers = letters.union(numbers)

print(letters_and_numbers)  # {'a', 'c', 1, 2, 3, 'b'}

# Intersection
#Divisible by 2
mod_2 = {2, 4, 6, 8, 10, 12, 14, 16, 18}
#Divisible by 3
mod_3 = {3, 6, 9, 12, 15, 18}

#Divisible by 2 and 3, also by 6
mod_6 = mod_2.intersection(mod_3)

print(mod_6)  # {18, 12, 6}

#Difference: returns everting in the first set except the itens that are in the second set to
bundle_1 = {"Resident Evil 3", "Final Fantasy VII", "Cyberpunk 2077"}
bundle_2 = {"Doom Eternal", "Halo Infinite", "Resident Evil 3"}

#The order of the sets matters
print( bundle_1.difference(bundle_2) ) # {'Cyberpunk 2077', 'Final Fantasy VII'}
print( bundle_2.difference(bundle_1) ) # {'Doom Eternal', 'Halo Infinite'}

# symmetric_difference gives us all of the items which only feature in one of the sets. Unlike difference the order of the sets doesn't matter.
bundle_1 = {"Resident Evil 3", "Final Fantasy VII", "Cyberpunk 2077"}
bundle_2 = {"Doom Eternal", "Halo Infinite", "Resident Evil 3"}

print(bundle_1.symmetric_difference(bundle_2)) # {'Cyberpunk 2077', 'Final Fanstay VII', 'Halo Infinite', 'Doom Eternal'}

